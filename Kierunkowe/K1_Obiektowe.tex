\section{K1 - Paradygmat programowania obiektowego}

\textbf{Paradygmat} - zbiór mechanizmów działania, wzorów, które definiują sposób realizacji programu.

Programowanie obiektowe stanowi podejście do implementacji algorytmów, które opiera się na wykorzystaniu tak zwanych \textbf{obiektów}. Są to twory, które łączą w sobie \textit{dane} (pola obiektu) i \textit{zachowania} (metody obiektu) oraz komunikują się ze sobą w celu wykonania pewnych zadań.

Paradygmat ten ma stanowić ułatwienie w pisaniu i utrzymywaniu kodu, który może być używany wielokrotnie w różnych projektach jednak nie jest odpowiedzią na wszystkie problemy i oprócz swoich zalet ma również wady -- np. przez to, że obiekty posiadają wewnętrzny stan, programowanie współbieżne staje się o wiele trudniejsze, gdyż musimy zapobiegać wyścigom czy zagłodzeniu.

Pojęciami, na których się skupię będą:
\begin{itemize}
	\item Klasa
	\item Abstrakcja
	\item Enkapsulacja
	\item Dziedziczenie
	\item Polimorfizm
	\item Wzorce projektowe
\end{itemize}

\subsection{Klasa}
Stanowi pewien zbiór cech i zachowań danego obiektu, który jest jej instancją.

Przykładem może być klasa \textit{Pies,} która zawiera cechy takie jak oczy, pysk oraz umiejętność szczekania.

Języki programowania umożliwiające definiowanie klas stanowią główny trzon języków obiektowych. Istnieje także druga grupa języków obiektowych, które oparte są na 
Języki programowania można podzielić ze względu na to, w jaki sposób pojęcie klasy jest zrealizowane. Na przykład w językach \textit{Java}, \textit{C\#} czy \textit{Python} każda klasa zawsze ma swoją klasę bazową (zazwyczaj dziedziczona niejawnie i jest to przeważnie klasa bazowa \textit{Object}). Język \textit{C++} na przykład, można nazwać językiem hybrydowym, gdyż umożliwia tworzenie obiektów, lecz nie zmusza do tego programisty (można programować zarówno strukturalnie jak i obiektowo). Istnieją także języki, których obiektowość opiera się na \textbf{prototypach} - nowe obiekty tworzone są w oparciu na istniejące już obiekty, nie zaś na podstawie zdefiniowanej klasy. Przykładem takiego języka jest większość języków interpretowanych, np. \textit{JavaScript}.

Głównym zyskiem obiektowości jest modularność - program można podzielić na mniejsze, gotowe do użycia moduły. Zwiększa to także czytelność kodu - łatwiej jest się odnaleźć w metodach przypisanych do obiektów niż w gąszczu funkcji.

\subsection{Abstrakcja}
Czyli poziom ogólności, pozwala nam na upraszczanie problemu poprzez zredukowanie właściwości do jedynie tych kluczowych dla algorytmu.

Dla przykładu - możemy mówić o \textit{Bazie danych} jako o fragmencie kodu, który będzie stanowił interfejs do komunikacji z pewną bazą danych, jednak nie ma to dla nas większego znaczenia w jaki sposób to będzie realizowane.

Przekładając to na banalny przykład z życia codziennego -- kierowca nie musi przechodzić szczegółowych szkoleń za każdym razem, gdy zmienia samochód.
Wystarczy mu jedynie podstawowa wiedza o jego działaniu, a takie rzeczy jak znajomość budowy silnika nie są mu potrzebne.

\subsection{Enkapsulacja}
Inaczej hermetyzacja, polega na celowym ukrywaniu wnętrza obiektów tak, aby zmiany w jego stanie mogły dokonać tylko metody wewnętrzne tego obiektu. Zwiększa to bezpieczeństwo kodu oraz odporność na błędy, a także pozwala podzielić kod na mniejsze fragmenty.

Problem pojawia się, gdy udostępnimy wersję klasy, która ma pewne pola publiczne.
Jeśli użytkownicy zaczną z tych pól korzystać, to aktualizacja może spowodować poważne problemy.

Enkapsulacja pomaga ustrzec nas przed niepożądanym korzystaniem z mechanizmów wewnątrz tworzonej przez nas klasy, a na użytek świata zewnętrznego pozwala nam wystawić tylko zdefiniowany przez nas interfejs.

Powracając do przykładu z samochodem -- kierowca powinien otwierać okno za pomocą guzika lub korbki, a nie poprzez wybijanie szyby.

Warto wspomnieć, że języki w różny sposób podchodzą do omawianych przeze mnie pojęć.
Python jest językiem, w którym pojęcie enkapsulacji praktycznie nie istnieje -- wszystko jest dostępne dla wszystkich i jeśli ktoś bardzo chce użyć zmiennych, które wyraźnie oznaczyliśmy jako do użytku wewnętrznego to może to zrobić na własną odpowiedzialność.

\subsection{Dziedziczenie}
Jest narzędziem, które dzięki odpowiednio zaprojektowanej relacji \textbf{klasa bazowa - klasa pochodna} pozwala na rozszerzanie funkcjonalności bez duplikowania kodu. Dzięki temu możemy tworzyć hierarchiczne struktury przechodząc od typów najbardziej ogólnych aż do tych szczegółowo opisujących dany obiekt bądź zjawisko.

W odniesieniu do samochodów -- możemy dostać wersję podstawową jakiegoś pojazdu, a następnie ją rozszerzyć o stylowe neony, naklejki z ogniem i spoilery.

\subsubsection{Dziedziczenie wielokrotne}
Tutaj znowu w zależności od języka możemy mieć możliwość skorzystania z mechanizmu dziedziczenia wielokrotnego lub nie. Językami to umożliwiającymi są na przykład \textit{C++} czy \textit{Python}. 

Polega ono na tym, że klasa pochodna może dziedziczyć po kilku klasach bazowych.
Jest to potężny mechanizm, jednak należy go używać z głową, gdyż może powodować problemy.

\subsection{Polimorfizm}
Pozwala nam na wyabstrahowanie pewnych zachowań od konkretnych typów danych. Dzięki niemu możemy wybrać zachowanie w zależności od kontekstu.

Dla odmiany rozpatrzmy przykład, w którym klasą \textbf{bazową} będzie \textbf{Zwierze,} a klasami \textbf{pochodnymi} będą \textbf{Pies} oraz \textbf{Ryba.}

Klasa bazowa ma zadeklarowaną metodę (funkcję, którą możemy wywołać na rzecz obiektu) o nazwie \textit{dajGlos.}

Klasy pochodne mogą tę funkcję zdefiniować po swojemu i w ten sposób po wywołaniu metody \textit{dajGlos} na obiekcie klasy \textit{Pies} usłyszymy szczekanie, a po wywołaniu metody na obiekcie klasy \textit{Ryba} usłyszymy tylko ciche bulgotanie, któremu towarzyszyć będzie bezgłośne osądzanie naszych wyborów życiowych.

Polimorfizm można podzielić na statyczny i dynamiczny. Polimorfizm \textbf{statyczny} (inaczej zwany \textit{wczesnym wiązaniem}) -- decyzja o użytym typie zostaje podjęta już na etapie kompilacji -- w języku \textit{C++} jest to realizowane za pomocą szablonów.  Polimorfizm \textbf{dynamiczny} (\textit{późne wiązanie}) -- wybór zostaje podjęty w czasie wykonywania programu -- w języku \textit{C++} zrealizowane przy użyciu wskaźników przeciążając metody wirtualne w klasach pochodnych.

\subsection{Wzorce projektowe}
Powstały, aby spisać często napotykane podczas programowania problemy oraz zdefiniować sprawdzone rozwiązania.

Jest to temat bardzo atrakcyjnych dla początkujących programistów i jest jednocześnie bardzo pomocny i bardzo niebezpieczny, ponieważ początkujący mogą chcieć korzystać ze wzorców gdzie tylko mogą, nie zważając na to czy faktycznie są one potrzebne.

Należy pamiętać o antywzorcach złotym młotku oraz srebrnym pocisku -- nie wszystko co się do tej pory sprawdziło gdzie indziej sprawdzi się w naszym przypadku, a to że doskonale znamy jakąś technologię nie znaczy, że jest ona zawsze odpowiednia.

Wzorce projektowe dzielimy wg trzech kategorii:
\begin{itemize}
	\item{konstrukcyjne -- opisujące proces tworzenia nowych obiektów, przykładowo \textbf{fabryka, singleton,}}
	\item{strukturalne -- opisujące struktury powiązanych ze sobą obiektów, przykładowo \textbf{adapter, dekorator,}}
	\item{behawioralne -- opisujące zachowanie i odpowiedzialność współpracujących ze sobą obiektów, przykładowo \textbf{strategia, null object.}}
\end{itemize}
